package com.by.hometasks.theory;

public class lab6Theory {
    /*
    Ура, мы дожили до 6 лабы ака введение в интерфейсы!

    Давай сначала пройдемя по основам и поймем что такое интерфейс

    Интерфейс - это супер абстракная вещь, которая является своего
    рода контрактом, который заключает класс, имплементирующий данный
    интерфейс

            т.е есть у нас работник, он приходит в офис и ему дают контракт
            со списком его обязанностей, которые он должен делать. Он его
            подписывает, тем самым обязуясь выполнить все из перечня.

        Тоже самое и тут, когда мы пишем
        class Person implements PersonServiceInterface
        мы обязуемся реализовать все методы в интерфейсе.


     Интерфейс это высшая степень абстракции.
     нельзя создать экземпляр интерфейса в Java,
     потому что интерфейс является абстрактным типом данных.
     Он содержит только объявления методов и констант,
     но не имеет конкретной реализации. Это означает,
     что объект типа интерфейса не имеет смысла, так как он не может
     выполнять какие-либо операции. Однако, вы можете создать
     экземпляр класса, который реализует интерфейс и использовать
     его для вызова методов интерфейса.

     Все методы в нем являются абстрактыми.

     Типы интерфейсов:
        -Обычные
        -Маркерные (без методов)
        -Функцилональные (один метод)

     В данной главе в книжке рассматриваюжтся все три, но для
     лабы нам нужен только первый тип.

     Такой интерфейс, после 9 версии Джавы претерпел несколько доработок

     Как я уже говорил, интерфейс служит для описания функциональности
     класса.
     По дефолту все методы там public abstract
     поля - константы т.е статические и финальные

     но в интерфейсах так же сущесвуют и приватные методы, статические
     и дефолтные методы

     Деолтные методы нужны для сокращения повторящегося кода.
     Если например наш метод должен просто считать сумму, то мы можем
     сразу в интерфейсе реализовать общую логику, чтоб по сто раз
     не писать реализацию:

     public interface MyInterface {
            default void myMethod(int a, int b) {
                  int result = a + b;
                  System.out.println("Result: " + result);
    }

    приватные методы реализуют инкапсуляцию и скрывают от пользователя
    внутренню реализацию, которую трогать не надо

    public interface MyInterface {
    default void myMethod() {
        // вызов приватного метода
        int result = calculate(1, 2);
        System.out.println("Result: " + result);

    // приватный метод
    private static int calculate(int a, int b) {
        return a + b;
    }
}


статические методы и переменные как мы знаем относятся не к экземпляру
а к самому классу. То есть нам не надо создавать объект

а что если приватный И статический?

Приватный статический метод в интерфейсе может быть использован в
любом методе в этом интерфейсе, а также в любом классе,
который реализует этот интерфейс. Это означает,
что любой метод интерфейса или класса, который
реализует этот интерфейс, может вызывать приватный статический метод.

Приватный нестатический метод в интерфейсе также может
быть использован в любом методе этого интерфейса.
Однако, поскольку приватный нестатический метод
связан с конкретным экземпляром интерфейса,
он может быть вызван только внутри этого экземпляра интерфейса.
То есть, только методы в этом интерфейсе могут вызывать приватный
нестатический метод, но не другие классы, которые
реализуют этот интерфейс.

В интерфейсе не могут быть объявлены поля без инициализации,
интерфейс в качестве полей содержит только public static final константы.
     */
}
