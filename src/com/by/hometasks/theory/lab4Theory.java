package com.by.hometasks.theory;

public class lab4Theory {
    /*
    Hello my dear student!
    В 4 лабе вы проходили Наследование и Полиморфизм
    Давай разберем все по порядку :)

    Итак начнем с наследования. Что это такое?

        Как тебе известно Джава это Объекто-ориентированный язык программирования, это значит, что
        все в нашем коде работает через объекты. Объект = экземпляр класса

        Dog dog = new Dog();

        Вот например dog, является объектом, это ты все знаешь)

        Как было написано выше, Джава -- это ООП язык, а у ООП есть 4 столпа, важных свойства:
            -Инкапсуляция
            -Наследование
            -Полиморфизм
            -Абстракция
        Нас интересует второй и кусочек третьего

        Наследование - свойство системы, которое позволяет создавать новый класс на основе уже
        существующего.
        Продолжим пример с собакой. Собака - это животное, которое может иметь, скажем так, наследников.
        Наследник у собаки есть щенок.

        public class Dog{
            private int age;
            private String name;

            тут констурктор

            сеттеры геттеры и тд
        }

        чтобы создать новый класс на основе класса Dog, мы должны сделать следующее

        public class Puppy extends Dog{
            какие-то поля

            конструктор

            методы
        }

        Нас интересует констурктор, потому что если мы его опеределим не правильно все будет не очень хорошо

        Когда мы создаем объект класса-наследника, он наследует все свойства и методы родительского класса,
        включая все поля, определенные в родительском классе.
        Если у класса-наследника нет определенного поля, которое есть у родительского класса,
        то при создании объекта класса-наследника в нем будет создано новое поле с таким же именем
        и значением по умолчанию.

        Это происходит потому, что класс-наследник наследует не только поведение,
        но и структуру родительского класса.
        Поэтому, если мы обращаемся к несуществующему полю объекта класса-наследника,
        то поиск будет продолжаться в родительском классе, и если поле с таким именем будет найдено там,
        то оно будет использовано. Если же такого поля не будет найдено ни в классе-наследнике,
        ни в родительском классе, то будет вызвано исключение (оно на самом деле пойдет выше до самого
        класса Object, но там нет например поля age).

        Если ты дошел до сюда, то ты гений мысли, молодэц

        Теперь перейдем к переопределению

        Переопределение - позволяет классу-наследнику предоставить собственную реализацию метода,
        который уже определен в родительском классе.
        Когда класс-наследник переопределяет метод,он предоставляет новую реализацию метода,
        которая заменяет реализацию метода в родительском классе.

        Компилятору об этом говорит анотация @override
        По сути, если ты ее уберешь, то ничего не случится, метод в классе наследнике просто
        будет существовать как новый метод, просто с таким же названием и входными праметрами. Но
        если ты изменишь метод в родительском классе, аннотация @override сразу накричит на тебя, что, мол,
        метод предка изменился, а метод наследника нет. Это относится к тому, если мы меняем возращаемый тип
        либо доавляем новый входной параметр.

        В принципе это вся теория по данной лабе, которую нужно держать в голове:
        -Наследование: на основе одного класса создаем другой
        -Переопределение: метод из класса родителя изменяем под нужды класса наследника
        -Наследование: все поля и методы родитедя на самом деле доступны в наследнике (кроме приватных)

        -------------------- ДОП ИНФА ------------------------
        Чтоб жизнь малиной не казалась, я сломаю тебе голову

        Когда ты создаешь объект класса наследника, то создается "два" объекта: наследник и родитель
        Таким образом новый объект наследника получит доступ ко всем полям родителя и его методы
        Почему? Потому что

        public Child(int parentField, int childField1, int childField2) {
            super(parentField); // вызываем конструктор родительского класса
            this.childField1 = childField1;
            this.childField2 = childField2;
       }

       При создании экземпляра класса-наследника, будет создан только ОДИН (ха наипал не два)) объект,
       который будет содержать как поля наследника, так и поля родительского класса.

       Это значит, что внутри объекта класса-наследника будет содержаться объект родительского класса,
       но не отдельный объект родительского класса. Внутренние поля родительского класса будут доступны
       внутри объекта класса-наследника, но в самом объекте класса-наследника будет только одно
       место для хранения всех полей (как наследника, так и родительского класса).

      ----------------ЕЩЕ БОЛЕЕ ДОП ИНФА---------------------
      Есть правила переопределения:
      -При переопределении методов запрещено менять кол-во параметров метода
      -При переопределении методов разрещено менять названия параметров
      -При переопределении методов разрешено менять ТИПЫ входных параметров, ТОЛЬКО ЕСЛИ новые тип прамаетра
      является НАСЛЕДНИКОМ/НА РАСШИРЕНИЕ (Object -> String, int -> long)
      -При переопределении методов разрешено менять модификатор доступа на БОЛЕЕ доступный (protected -> public)

      -При переопределении методаможно изменить тип возвращаемого значения на более конкретный тип.
       Например, если в родительском классе метод возвращает тип Object,
       то в наследнике можно изменить тип возвращаемого значения на более конкретный тип,
       например, на String или Integer. Это связано с тем, что объекты типа String и Integer
       являются подтипами типа Object и могут быть безопасно приведены к типу Object.

       Однако, если в родительском классе метод возвращает более конкретный тип,
       то в наследнике нельзя изменить тип возвращаемого значения на более общий тип.
       Например, если в родительском классе метод возвращает тип String, то в наследнике нельзя
       изменить тип возвращаемого значения на Object, так как это может привести к ошибке во
       время выполнения программы.

        Кроме того, при переопределении метода в Java важно соблюдать принцип подстановки Лисков (Liskov substitution principle),
        который гласит, что объекты типа наследника должны быть безопасны для использования вместо
        объектов типа родительского класса. Это означает, что тип возвращаемого значения метода в
        наследнике должен быть совместим с типом возвращаемого значения метода в родительском классе или
        должен быть его подтипом.
     */
}
